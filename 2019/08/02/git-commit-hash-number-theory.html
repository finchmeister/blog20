<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Git Commit Hash Number Theory | Personal Blog of Jonathan Finch</title><meta name="generator" content="Jekyll v3.9.0" /><meta property="og:title" content="Git Commit Hash Number Theory" /><meta name="author" content="Jonathan Finch" /><meta property="og:locale" content="en_US" /><meta name="description" content="How rare is an all digit commit hash?" /><meta property="og:description" content="How rare is an all digit commit hash?" /><link rel="canonical" href="https://finchmeister.github.io/blog20/2019/08/02/git-commit-hash-number-theory" /><meta property="og:url" content="https://finchmeister.github.io/blog20/2019/08/02/git-commit-hash-number-theory" /><meta property="og:site_name" content="Personal Blog of Jonathan Finch" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2019-08-02T00:00:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Git Commit Hash Number Theory" /><meta name="twitter:site" content="@" /><meta name="twitter:creator" content="@Jonathan Finch" /> <script type="application/ld+json"> {"description":"How rare is an all digit commit hash?","url":"https://finchmeister.github.io/blog20/2019/08/02/git-commit-hash-number-theory","@type":"BlogPosting","headline":"Git Commit Hash Number Theory","dateModified":"2019-08-02T00:00:00+00:00","datePublished":"2019-08-02T00:00:00+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://finchmeister.github.io/blog20/2019/08/02/git-commit-hash-number-theory"},"author":{"@type":"Person","name":"Jonathan Finch"},"@context":"https://schema.org"}</script><link rel="shortcut icon" href="/favicon.png"><link rel="alternate" type="application/atom+xml" title="Personal Blog of Jonathan Finch" href="/atom.xml"><link rel="alternate" title="Personal Blog of Jonathan Finch" type="application/json" href="https://finchmeister.github.io/blog20/feed.json" /><link rel="sitemap" type="application/xml" title="sitemap" href="/sitemap.xml" /><style type="text/css"> body{font-family:-apple-system,BlinkMacSystemFont,'avenir next',avenir,Noto Sans,helvetica,'helvetica neue',sans-serif}body{font-size:1rem;line-height:1.5;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility}a,a:visited{color:inherit}a:hover,a:visited:hover{color:dodgerblue}blockquote{background:#f9f9f9;border-left:5px solid black;font-size:120%;margin:2rem 0;padding:1rem}blockquote p{margin:0}blockquote footer{font-size:80%;margin:1rem 0 0 0}dl dt{margin-bottom:0.5rem}dl dd{font-style:italic;margin-bottom:2rem}code,.highlight{background:#edf2f7;overflow:auto}code{word-break:break-all}pre{padding:1em}.date{opacity:0.6}html{box-sizing:border-box;margin:0;padding:0}*,*:before,*:after{box-sizing:inherit}body{background-color:#edf2f7;color:#495057}header,main{margin:0 auto;max-width:50rem}main{background:white;border:2px solid #e9ecef;-webkit-box-shadow:0 0.75rem 1.5rem rgba(18,38,63,0.03);box-shadow:0 0.75rem 1.5rem rgba(18,38,63,0.03);padding:2rem 3rem}ul,ol{padding:0;list-style-position:inside}table{border-collapse:collapse;text-align:left;width:100%}table tr{border-bottom:1px solid black}table td{padding:0.5rem}img{width:100%;margin:0.5rem 0}nav ul{list-style:none !important;padding:0;text-align:right}nav ul li{display:inline-block}nav a,nav a:visited{margin:0.5rem;text-decoration:none;font-size:0.875rem;text-transform:uppercase;color:inherit}footer{margin:1rem 0;text-align:center;color:inherit}video{margin-left:auto;margin-right:auto;display:block}.highlight .hll{background-color:#ffc}.highlight .c{color:#408080;font-style:italic}.highlight .err{border:1px solid red}.highlight .k{color:#008000;font-weight:bold}.highlight .o{color:#666}.highlight .cm{color:#408080;font-style:italic}.highlight .cp{color:#BC7A00}.highlight .c1{color:#408080;font-style:italic}.highlight .cs{color:#408080;font-style:italic}.highlight .gd{color:#A00000}.highlight .ge{font-style:italic}.highlight .gr{color:red}.highlight .gh{color:#000080;font-weight:bold}.highlight .gi{color:#00A000}.highlight .go{color:gray}.highlight .gp{color:#000080;font-weight:bold}.highlight .gs{font-weight:bold}.highlight .gu{color:#800080;font-weight:bold}.highlight .gt{color:#0040D0}.highlight .kc{color:#008000;font-weight:bold}.highlight .kd{color:#008000;font-weight:bold}.highlight .kn{color:#008000;font-weight:bold}.highlight .kp{color:green}.highlight .kr{color:#008000;font-weight:bold}.highlight .kt{color:#B00040}.highlight .m{color:#666}.highlight .s{color:#BA2121}.highlight .na{color:#7D9029}.highlight .nb{color:green}.highlight .nc{color:#0000FF;font-weight:bold}.highlight .no{color:#800}.highlight .nd{color:#a2f}.highlight .ni{color:#999999;font-weight:bold}.highlight .ne{color:#D2413A;font-weight:bold}.highlight .nf{color:blue}.highlight .nl{color:#A0A000}.highlight .nn{color:#0000FF;font-weight:bold}.highlight .nt{color:#008000;font-weight:bold}.highlight .nv{color:#19177C}.highlight .ow{color:#AA22FF;font-weight:bold}.highlight .w{color:#bbb}.highlight .mf{color:#666}.highlight .mh{color:#666}.highlight .mi{color:#666}.highlight .mo{color:#666}.highlight .sb{color:#BA2121}.highlight .sc{color:#BA2121}.highlight .sd{color:#BA2121;font-style:italic}.highlight .s2{color:#BA2121}.highlight .se{color:#BB6622;font-weight:bold}.highlight .sh{color:#BA2121}.highlight .si{color:#BB6688;font-weight:bold}.highlight .sx{color:green}.highlight .sr{color:#b68}.highlight .s1{color:#BA2121}.highlight .ss{color:#19177C}.highlight .bp{color:green}.highlight .vc{color:#19177C}.highlight .vg{color:#19177C}.highlight .vi{color:#19177C}.highlight .il{color:#666}</style></head><body> <span class="over"></span><header role="banner"><nav role="navigation"><ul><li><a href="/" >Home</a></li><li><a href="/tags" >Tags</a></li><li><a href="/about" >About</a></li><li><a href="/projects" >Projects</a></li><!--<li><a href="/atom.xml">Feed</a></li>--></ul></nav></header><main id="main" role="main"><article role="article"><h1>Git Commit Hash Number Theory</h1><time class="date" datetime="2019-08-02T00:00:00+00:00">August 2, 2019</time><p>Life as a programmer is often mundane. You start with a brief to make something happen on a screen. Spend hours upon hours sat at a desk, typing and tapping away, before eventually finding out the feature you’ve just lovingly crafted isn’t needed anymore. It means that small, out of the ordinary events in the software development process can catch one’s curiosity and lead to unexpected tangents in the pursuit of knowledge, such as ‘how rare is this <em>all digit</em> git commit hash I have just generated?’</p><p><img src="/assets/git-number-theory/shortgitcommit.png" alt="Short commit" /> <img src="/assets/git-number-theory/gitcommit.png" alt="Full commit" /></p><p>I was sure I had seen these things before, but I had no clue as to the significance of it, so I went on a journey to find out.</p><p>At a high level, a git commit hash is a SHA1 hash of the state of the git repository at the time of the commit. A short git commit hash is an abbreviation of the hash to the first 7 characters, it is almost certainly unique within a repository and git will increase the number of characters used if it is not.</p><p>To empirically find out the probability of an all digit hash, I wrote a simulation that generated a lot of SHA1 hashes and returned the percentage of the total which start with 7 digits.</p><p>It takes just a single character in the hash subject to change for the hash output to be vastly different, (called the <em>avalanche effect</em>), so for ease I simply increment a counter (known as the <em>nonce</em>) to generate a new hash subject.</p><p>As an aside, Bitcoin does something similar in its proof of work algorithm to generate blocks and prevent tampering to the blockchain. It relies on incrementing a counter and generating a hash based upon the transaction log until the resulting hash starts with a certain number of 0s (depending on the network difficulty). It is very easy to verify the hash but takes a lot of computational power to generate a valid one in the first place. This is known as the <a href="https://en.bitcoin.it/wiki/Hashcash">HashCash</a> proof of work system.</p><p>The PHP script:</p><div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?php</span>

<span class="k">function</span> <span class="n">getShortHash</span><span class="p">(</span><span class="kt">string</span> <span class="nv">$subject</span><span class="p">):</span> <span class="kt">string</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nb">substr</span><span class="p">(</span><span class="nb">sha1</span><span class="p">(</span><span class="nv">$subject</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">function</span> <span class="n">isAllInt</span><span class="p">(</span><span class="kt">string</span> <span class="nv">$subject</span><span class="p">):</span> <span class="kt">bool</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nb">preg_match</span><span class="p">(</span><span class="s1">'/^\d{7}$/'</span><span class="p">,</span> <span class="nv">$subject</span><span class="p">)</span> <span class="o">===</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="nv">$n</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span>
<span class="nv">$allInt</span> <span class="o">=</span> <span class="nv">$notAllInt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nv">$randomBytes</span> <span class="o">=</span> <span class="nb">random_bytes</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="nv">$i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nv">$i</span> <span class="o">&lt;</span> <span class="nv">$n</span><span class="p">;</span> <span class="nv">$i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$subject</span> <span class="o">=</span> <span class="nv">$randomBytes</span> <span class="mf">.</span> <span class="nv">$i</span><span class="p">;</span>
    <span class="nv">$shortHash</span> <span class="o">=</span> <span class="nf">getShortHash</span><span class="p">(</span><span class="nv">$subject</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nf">isAllInt</span><span class="p">(</span><span class="nv">$shortHash</span><span class="p">))</span> <span class="p">{</span>
        <span class="nv">$allInt</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nv">$notAllInt</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nv">$ratio</span> <span class="o">=</span> <span class="nv">$allInt</span><span class="o">/</span><span class="nv">$n</span> <span class="o">*</span> <span class="mi">100</span><span class="p">;</span>

<span class="k">echo</span> <span class="s2">"All int: </span><span class="si">{</span><span class="nv">$allInt</span><span class="si">}</span><span class="s2">; Not all int: </span><span class="si">{</span><span class="nv">$notAllInt</span><span class="si">}</span><span class="s2">; All int: </span><span class="si">{</span><span class="nv">$ratio</span><span class="si">}</span><span class="s2"> %</span><span class="se">\n</span><span class="s2">"</span><span class="p">;</span>
</code></pre></div></div><p>The results after running the script 5 times:</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>All int: 387<span class="p">;</span> Not all int: 9613<span class="p">;</span> All int: 3.87 %
All int: 408<span class="p">;</span> Not all int: 9592<span class="p">;</span> All int: 4.08 %
All int: 356<span class="p">;</span> Not all int: 9644<span class="p">;</span> All int: 3.56 %
All int: 374<span class="p">;</span> Not all int: 9626<span class="p">;</span> All int: 3.74 %
All int: 357<span class="p">;</span> Not all int: 9643<span class="p">;</span> All int: 3.57 %
</code></pre></div></div><p>We can see between 3.56% and 4.08% of random SHA1 hashes will start with 7 integers - roughly 1 in 27. In reality, all digit short hashes are not that rare.</p><p>Let’s look a bit deeper as to <em>why</em> the probability of all integer short hashes is around 1 in 27.</p><p>A SHA1 hash is represented here as a 40 character hexadecimal string. Each character in hexadecimal has 16 options, 0-9 or a-f. Assuming a SHA1 hash has a seemingly random output where each character is equally likely to be selected upon a hash, then the likelihood of the first character being an integer is 10/16, the second is also 10/16, and so on for the first 7 characters. We can calculate the probably like so:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>10/16 * 10/16 * 10/16 * 10/16 * 10/16 * 10/16 * 10/16 
= (10/16)^7
= 10000000/268435456
= 0.03725290298
</code></pre></div></div><p>i.e.: 3.725% or 1 in 26.67.</p><p>3.725% fits within the range of values computed by the simulation, validating that the theory and the practice tie up.</p><p>According to the law of large numbers, as we increase the number of trials, the average of the result will tend towards the true expected value. The mathematics tells us that the expected value is 3.725%, so let’s see what happens if we run the script with a much higher number of iterations.</p><p>Upping the iterations of the script by 5000 to 500 million and running this on an oversized Google Cloud Platform VM we get:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>All int: 18630499; Not all int: 481369501; All int: 3.7260998 %
</code></pre></div></div><p>Extremely close to the expected value, just a 0.02952483% difference. This demonstrates that the output of SHA1 algorithm is seemingly random even though we are only incrementing a counter in the hash subject - the <em>avalanche effect</em>. This is what we would expect from a hashing algorithm, if there were a correlation between the input and output, the hashing algorithm would be considered broken as it would open up the possibility of reversing a hash via a cryptanalytic attack.</p><h2 id="how-about-git-hashes-that-are-all-letters">How about git hashes that are all letters?</h2><p>Naturally I considered how rare all letter short git hashes were:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>All letters: 12; Not all letters: 9988; All letters: 0.12 %
All letters: 10; Not all letters: 9990; All letters: 0.1 %
All letters: 14; Not all letters: 9986; All letters: 0.14 %
All letters: 11; Not all letters: 9989; All letters: 0.11 %
All letters: 7; Not all letters: 9993; All letters:: 0.07 %
</code></pre></div></div><p>Following the same logic as before but with 6 possible characters (a-f) we get</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(6/16)^7 = 0.001042842865 ~ 0.1%. 
</code></pre></div></div><p>I.e., 1 in 959 commits.</p><p>A much, much rarer event.</p><h2 id="what-is-the-rarest-commit-hash-i-could-find-in-the-wild">What is the rarest commit hash I could find in the wild?</h2><p>I took a look at the biggest git repo I could think of, the Linux kernel, which at the time of writing was 2.5GB and had 856,459 commits. I extracted the commit hashes to a file then grepped for the longest starting sequence of letters and digits.</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/linux<span class="nv">$ </span>git log <span class="nt">--pretty</span><span class="o">=</span>oneline | <span class="nb">cut</span> <span class="nt">-c</span> 1-40 <span class="o">&gt;</span> git_log.log
~/linux<span class="nv">$ </span><span class="nb">grep</span> <span class="nt">-E</span> <span class="s2">"^[0-9]{27,}"</span> git_log.log 
932505776779430053766113965c21cfb7ab823a
287774414568010855642518513f085491644061

~/linux<span class="nv">$ </span><span class="nb">grep</span> <span class="nt">-E</span> <span class="s2">"^[a-z]{15,}"</span> git_log.log 
fdbdfefbabefcdf3f57560163b43fdc4cf95eb2f
</code></pre></div></div><p>There are some pretty unusual hashes there, two starting with 27 digits, a 1 in 324,518 chance, and <a href="https://github.com/torvalds/linux/commit/fdbdfefbabefcdf3f57560163b43fdc4cf95eb2f">one</a> starting with 15 letters, a 1 in 2,452,059 chance. You’ve got more chances of winning £10,000 every month for one year with the National Lottery - Set For Life lottery <a href="https://en.wikipedia.org/wiki/National_Lottery_(United_Kingdom)#Set_For_Life">1 in 1,704,377</a> than getting a git commit hash that looks like that.</p><p>Who’d have thought the life of a programmer was mundane now?</p><br><p> Tagged <a class="post" href="/tag/tech">#tech</a>.</p><hr style="height:2px; border:none; margin: 2rem 0; background-color:#e7e9ee;"><div class="disqus"></div><div class="disqus-loading">Loading comments&hellip;</div><style> .disqus-placeholder.is-hidden { display: none; }</style><script> (function(b,f,l){var r=function(a){a=a.getBoundingClientRect();return{top:a.top+f.body.scrollTop,left:a.left+f.body.scrollLeft}},t=function(a,c){var d=f.createElement("script");d.src=a;d.async=!0;d.setAttribute("data-timestamp",+new Date);d.addEventListener("load",function(){"function"===typeof c&&c()});(f.head||f.body).appendChild(d)};l=function(a,c){var d,e;return function(){var g=this,f=arguments,b=+new Date;d&&b<d+a?(clearTimeout(e),e=setTimeout(function(){d=b;c.apply(g,f)},a)):(d=b,c.apply(g, f))}};var m=!1,n=!1,p=!1,k=!1,h="unloaded",e=!1,q=function(){if(!e||!f.body.contains(e)||"loaded"==e.disqusLoaderStatus)return!0;var a=b.pageYOffset,c=r(e).top;if(c-a>b.innerHeight*n||0<a-c-e.offsetHeight-b.innerHeight*n)return!0;(a=f.getElementById("disqus_thread"))&&a.removeAttribute("id");e.setAttribute("id","disqus_thread");e.disqusLoaderStatus="loaded";"loaded"==h?DISQUS.reset({reload:!0,config:p}):(b.disqus_config=p,"unloaded"==h&&(h="loading",t(k,function(){h="loaded"})))};b.addEventListener("scroll", l(m,q));b.addEventListener("resize",l(m,q));b.disqusLoader=function(a,c){var d={laziness:1,throttle:250,scriptUrl:!1,disqusConfig:!1},b=c,g,h={};for(g in d)Object.prototype.hasOwnProperty.call(d,g)&&(h[g]=d[g]);for(g in b)Object.prototype.hasOwnProperty.call(b,g)&&(h[g]=b[g]);c=h;n=c.laziness+1;m=c.throttle;p=c.disqusConfig;k=!1===k?c.scriptUrl:k;e="string"===typeof a?f.querySelector(a):"number"===typeof a.length?a[0]:a;e.disqusLoaderStatus="unloaded";q()}})(window,document,0); </script> <script> disqusLoader( '.disqus', { scriptUrl: '//{"name"=>"thefinchmeister", "noscript"=>"Please enable JavaScript to view the comments powered by Disqus."}.disqus.com/embed.js', disqusConfig: function() { this.page.identifier = '/2019/08/02/git-commit-hash-number-theory'; this.page.url = '/2019/08/02/git-commit-hash-number-theory'; this.page.title = 'Git Commit Hash Number Theory'; this.callbacks.onReady = [function() { var el = document.querySelector( '.disqus-loading' ); if( el.classList ) el.classList.add( 'is-hidden' ); else el.className += ' ' + 'is-hidden'; }]; } }); </script></article></main><footer class="footer" role="contentinfo"> <small> Personal blog of Jonathan Finch - <a href="https://github.com/finchmeister/blog20">Source</a> </small></footer></body></html>
